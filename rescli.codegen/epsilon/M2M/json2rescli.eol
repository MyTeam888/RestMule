import "../util/json.eol";
import "../util/rescli.eol";

operation String responseFormat() : Any {
 	if (self.toLowerCase().matches(".*xml.*")){
 		return RESCLI!FormatEnum#XML;
 	}
 	if (self.toLowerCase().matches(".*json.*")){
 		return RESCLI!FormatEnum#JSON;
 	} 
 	return null; 
}

operation Any reqParam(label : String) : Any {
	var param;
	switch (self.s_in.toLowerCase()){
	case "header":
		param = new RESCLI!RequestHeader;
		param.type = self.simpleType(label);
	case "query": 
		param = new RESCLI!Query;
		param.type = self.simpleType(label);
	case "path":
		param = new RESCLI!Path;
		param.type = self.simpleType(label);
	case "body":
		param = new RESCLI!Body;
		param.type = self.definition();
		param.type.name = param.type.name + "Body"; 
	default:
		return null;
	}
	param.description =	self.s_description;
	param.required = self.s_required.asBoolean();
	return param;
}

operation Any definition(): Any {
	if (self.properties.has("schema")){
		if (self.e_schema.properties.has("$ref")){
			var name = self.e_schema.`s_$ref`.getDef();
			var root = JSON.getRoot;
			if (root.e_definitions.properties.has(name)){
				var def = root.e_definitions.properties.select(p | p.id == name).first;
				return def.nest();
			} else {
				return self.e_schema.properties.nest();
			}
		} 
	} else {
		return null;
	}
}

operation Any reqParam() : Any {
	return self.reqParam(self.s_name);
}

operation Any nest() : Any {
	return self.nest(self.id);
}

operation Any nest(name : String) : Any {
	("self.id=" + self.id +", name=" + name).println;
	if (self.s_type == "object" or (
		self.s_type=="null" and self.properties.has("properties"))) {
		var type = new RESCLI!ObjectType;
		if (self.s_type<>"null"){
			type.label = name;
		} elseÂ {
			"null type in object nest ".println;
			type.label = name;
		}
		type.name = type.label.sanitizeClass();
		type.description = self.s_description;
		if (self.properties.has("properties")){
			for (prop in self.e_properties.properties.flatten){	
				prop.handleObjectProperties(type);
				type.required = true;
			}
		} 
		if (self.properties.has("additionalProperties")){
			"unhandled additional properties".println;
		}
		return type;
	} else if (self.s_type == "array"){
		return self.handleArray();
	} else if (self.s_type == "null"){
		return self.handleNull();
	} else {
		return self.simpleType();
	}
}

operation Any handleObjectProperties(object : RESCLI!ObjectType) : Any {
	var field;
	switch(self.s_type.toLowerCase()){
	case "object":
		var p = self.nest();
		if (p <> null ){
			object.nestedObjects.add(p);
		}
	case "array":
		var a = self.handleArray();
		if (a <> null ){
			object.listFields.add(a);
		}	
	case "null":
		var e = self.handleNull();
		if (e <> null){
			if (e.instanceOf(RESCLI!TFormattedString) 
			or e.instanceOf(RESCLI!UndefinedType)){
				object.attributes.add(e);
			} else if (e.instanceOf(RESCLI!ObjectType)){
				object.nestedObjects.add(e);
			}
		}
	default:
		var f = self.simpleType();
		if (f <> null){
			object.attributes.add(f);
		}
	}
}

operation Any handleArray() : RESCLI!ListType{
	("handleArray " + self.id) .println;
	var type = new RESCLI!ListType;
	type.label = self.id;
	type.name = type.label.sanitizeClass();
	type.description = self.s_description;
	var p = self.e_items.nest(self.id);
	p.label = type.label;
	p.name = type.name.sanitizeFieldName();
	type.elements.add(p);
	return type;
}

operation Any handleNull() : Any{
	var field;
	("handlin null" + self.id + " " + self.properties.collect(e|e.id)).println;
	if (self.properties.has("enum")){
		field = new RESCLI!TFormattedString;
		field.pattern = "(" + self.e_enum.children.collect(e|e.value).flatten.concat("|") + ")";
		field.label = self.id;
		field.name = field.label.sanitizeFieldName();
		field.description = self.s_description;
		return field;
	} else if (self.properties.has("properties")){
		return self.nest(self.id);
	} else {
		field = new RESCLI!UndefinedType;
		field.label = self.id;
		field.name = field.label.sanitizeFieldName();
		field.description = self.s_description;
		return field;
	}
}

operation Any simpleType() : Any {
	return self.simpleType(self.id);
}

operation Any simpleType(label : String) : Any {
	var field;
	switch (self.s_type){
	case "string":
		if (self.properties.flatten.has("format")){
			switch (self.s_format){
			case "byte":
				field = new RESCLI!TByte;
			case "binary":
				field = new RESCLI!TBinary;
			case "date":
				field = new RESCLI!TDate;
			case "date-time":
				field = new RESCLI!TDateTime;
			case "password":
				field = new RESCLI!TFormattedString;
			} 
		}
		if (self.properties.flatten.has("pattern")){
			if (field == null or not field.isKindOf(RESCLI!TFormattedString)){
				field = new RESCLI!TFormattedString;
			}
			field.pattern = self.s_pattern;
		} else if (self.properties.has("enum")) {
			if (field == null or not field.isKindOf(RESCLI!TFormattedString)){
				field = new RESCLI!TFormattedString;
			}
			field.pattern = "(" + self.e_enum.children.collect(e|e.value).flatten.concat("|") + ")";
		} else{
			field = new RESCLI!TString;
		}
	case "boolean":
		field = new RESCLI!TBoolean;
		field.`default` = self.s_default.toBoolean();
	case "number":
		switch (self.s_format){
		case "double":
			field = new RESCLI!TDouble;
			field.max = self.s_maximum.toReal();
			field.min = self.s_maximum.toReal();
		default:
			field = new RESCLI!TFloat;	
			field.max = self.s_maximum.toReal();
			field.min = self.s_maximum.toReal();
		}
		field.maxExclusive = self.s_exclusiveMaximum.toBoolean();
		field.minExclusive = self.s_exclusiveMinimum.toBoolean();
	case "integer":
		switch (self.s_format){
		case "int64":
			field = new RESCLI!TLong;
			field.max = self.s_minimum.toInt();
			field.min = self.s_maximum.toInt();
		default:
			field = new RESCLI!TInteger;
			field.max = self.s_maximum.toInt();
			field.min = self.s_maximum.toInt();
		}
		field.maxExclusive = self.s_exclusiveMaximum.toBoolean();
		field.minExclusive = self.s_exclusiveMinimum.toBoolean();
	default: 
		("unhandled " + self.s_type).println;
		return null;	
	}
	field.label = label;
	field.name = field.label.sanitizeFieldName();
	field.description = self.s_description;
	return field;
}

operation String isValidPath() : Boolean {
	return self.matches("((/\\{[a-zA-Z\\d_\\-]*\\})|(/[a-zA-Z\\d_\\-]*))*");
}